name: Keep Backend Alive

on:
  schedule:
    # Run every 10 minutes to prevent Render free tier from sleeping
    # Render free tier spins down after 15 minutes of inactivity
    # Note: GitHub Actions scheduled workflows may be delayed during high load
    - cron: "*/10 * * * *"

  # Allow manual trigger for testing
  workflow_dispatch:

jobs:
  ping:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Extended timeout to handle Render free tier cold starts (30-90 seconds)
    # Strategy: 5 retries √ó 30s timeout + exponential backoff (15s, 30s, 60s, 120s)
    # Total max wait: ~3 minutes to accommodate slow cold starts

    steps:
      - name: Validate Backend URL Secret
        run: |
          if [ -z "${{ secrets.BACKEND_URL }}" ]; then
            echo "‚ùå Error: BACKEND_URL secret is not set in GitHub repository settings"
            echo "Please set BACKEND_URL secret under Settings > Secrets and variables > Actions"
            exit 1
          fi
          echo "‚úÖ BACKEND_URL secret is configured"
          echo "üìç Backend URL: ${{ secrets.BACKEND_URL }}"

      - name: Ping Backend Keep-Alive Endpoint
        id: ping
        run: |
          echo "========================================="
          echo "üèì Pinging backend at $(date)"
          echo "========================================="

          BACKEND_URL="${{ secrets.BACKEND_URL }}"
          ENDPOINT="${BACKEND_URL}/api/ping"
          MAX_RETRIES=5
          RETRY_DELAY=15
          SUCCESS=false

          # Function to ping with retry logic and exponential backoff
          # Designed to handle Render free tier cold starts which can take 30-90+ seconds
          ping_with_retry() {
            local attempt=1
            local delay=$RETRY_DELAY
            
            while [ $attempt -le $MAX_RETRIES ]; do
              echo ""
              echo "Attempt $attempt of $MAX_RETRIES..."
              
              # Create temp file for response body
              temp_file=$(mktemp)
              
              # Make request with timeout and capture response code, time, and body in one call
              # curl writes: body to file, then status code and time to stdout
              curl_output=$(curl -s -w "\n%{http_code}\n%{time_total}" \
                --max-time 30 \
                --silent \
                --show-error \
                -o "$temp_file" \
                "${ENDPOINT}" 2>&1)
              
              curl_exit_code=$?
              
              # Extract components from curl output
              # Last line is response time, second to last is HTTP code
              response_time=$(echo "$curl_output" | tail -n 1)
              http_code=$(echo "$curl_output" | tail -n 2 | head -n 1)
              
              # Get response body
              if [ -f "$temp_file" ]; then
                response_body=$(cat "$temp_file" 2>/dev/null || echo "")
                rm -f "$temp_file"
              else
                response_body=""
              fi
              
              # If curl failed completely, set error code
              if [ $curl_exit_code -ne 0 ] && [ -z "$http_code" ]; then
                http_code="000"
              fi
              
              # Check if we got a successful response
              if [ "$http_code" = "200" ]; then
                echo "‚úÖ Backend responded successfully!"
                echo "üì° HTTP Status: $http_code"
                echo "‚è±Ô∏è  Response Time: ${response_time}s"
                if [ -n "$response_body" ]; then
                  echo "üìÑ Response: $response_body"
                fi
                
                # Output response time for summary
                echo "response_time=${response_time}" >> $GITHUB_OUTPUT
                SUCCESS=true
                return 0
              else
                echo "‚ö†Ô∏è  Attempt $attempt failed"
                echo "üì° HTTP Status: ${http_code:-'Connection failed'}"
                if [ -n "$response_body" ] && [ "$response_body" != "null" ]; then
                  echo "üìÑ Response: $response_body"
                fi
                
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "‚è≥ Waiting ${delay}s before retry..."
                  sleep $delay
                  delay=$((delay * 2)) # Exponential backoff: 15s, 30s, 60s, 120s
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            return 1
          }

          # Execute ping with retries
          if ping_with_retry; then
            echo ""
            echo "========================================="
            echo "‚úÖ Keep-alive ping completed successfully"
            echo "========================================="
          else
            echo ""
            echo "========================================="
            echo "‚ö†Ô∏è  Keep-alive ping failed after $MAX_RETRIES attempts"
            echo "‚ÑπÔ∏è  This is likely due to a cold start timeout on Render free tier"
            echo "‚ÑπÔ∏è  The service will wake up on the next successful ping or user request"
            echo "========================================="
            exit 0
          fi

      - name: Summary
        if: success()
        run: |
          echo "‚úÖ Backend Status: Healthy"
          echo "üèì Keep-alive ping successful"
          echo "‚è±Ô∏è  Response Time: ${{ steps.ping.outputs.response_time }}s"
          echo "üïê Next ping scheduled in 10 minutes"
          echo ""
          echo "The backend will remain active on Render free tier."

      - name: Alternative Notification (Rare)
        if: failure()
        run: |
          echo "‚ö†Ô∏è  Workflow encountered an unexpected error"
          echo "‚ÑπÔ∏è  This is different from a ping timeout and may indicate:"
          echo ""
          echo "  - GitHub Actions infrastructure issue"
          echo "  - Missing or invalid BACKEND_URL secret"
          echo "  - Workflow configuration error"
          echo ""
          echo "Note: Ping timeouts no longer fail the workflow."
